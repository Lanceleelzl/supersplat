# GLB模型原位复制功能修复

## 修复的问题

### 问题1: 复制后新模型不显示
**现象**: 原位复制后，新模型不会自动显示，需要在场景管理中手动显示隐藏才能看到。

**原因分析**:
1. 复制的模型实体没有被正确启用
2. 场景渲染没有及时刷新
3. 缺少必要的事件触发来更新UI

**修复方案**:
1. 在复制完成后确保所有实体都被启用
2. 强制刷新场景渲染
3. 添加延迟选中机制确保渲染完成

### 问题2: 复制模型命名不规范
**现象**: 复制的模型使用英文"_copy"作为后缀

**修复方案**: 改为中文"_复制"后缀

## 修改的文件

### 1. `src/gltf-model.ts`
- 添加了自定义文件名属性 `_customFilename`
- 修改构造函数支持自定义文件名参数
- 添加 `setCustomFilename()` 方法
- 修改 `filename` getter 优先返回自定义文件名

### 2. `src/editor.ts`  
- 修改 `cloneGltfModel()` 函数使用自定义文件名
- 修改 `duplicateGltfModel()` 函数使用中文"_复制"后缀
- 添加强制渲染刷新逻辑
- 修改复制事件处理，确保新模型正确显示

### 3. `src/ui/context-menu.ts`
- 修改复制方法添加延迟刷新机制
- 优化复制完成后的状态处理

## 修复后的功能

### 自动命名规则
- 原模型名: `drone.glb`
- 复制后名: `drone.glb_复制`

### 显示刷新机制
1. 复制完成后强制刷新场景渲染
2. 确保所有子实体都被正确启用
3. 延迟选中新模型，避免时序问题

### 实体启用逻辑
```typescript
// 确保新模型的实体被正确启用和显示
if (duplicatedModel.entity) {
    duplicatedModel.entity.enabled = true;
    
    // 确保所有子实体也被启用
    function enableEntity(entity: any) {
        entity.enabled = true;
        if (entity.children) {
            entity.children.forEach((child: any) => enableEntity(child));
        }
    }
    enableEntity(duplicatedModel.entity);
}
```

## 测试步骤

1. **加载GLB模型**: 将一个GLB模型拖入场景
2. **选择模型**: 左键点击选中模型
3. **右键复制**: 右键点击选中的模型，选择"原位复制"
4. **验证结果**:
   - 新模型应该立即显示在原模型旁边（X轴偏移1个单位）
   - 新模型自动命名为"原名称_复制"
   - 新模型自动被选中并显示在属性面板中
   - 不需要手动刷新即可看到新模型

## 技术要点

### 实体克隆
- 使用 `entity.clone()` 方法克隆原始实体
- 保持所有原始属性（位置、旋转、缩放、材质等）

### 文件名管理
- 通过自定义文件名属性避免修改资产名称
- 支持灵活的命名策略

### 渲染刷新
- 使用 `scene.forceRender = true` 强制刷新
- 结合事件系统确保UI同步更新

### 异步处理
- 使用 `setTimeout` 处理渲染时序问题
- 确保复制、渲染、选中的正确顺序

## 注意事项

1. 复制操作是同步的，但渲染更新可能需要时间
2. 新模型会自动偏移1个单位避免重叠
3. 所有复制的模型都会继承原模型的所有属性
4. 复制功能只对GLB/glTF模型有效